<!DOCTYPE html>
<html>
  <head>
    <style>
      canvas {
        border: 4px solid #131313;
        height: 400px;
        width: 600px;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <!-- these shaders could also be loaded via ajax, or described as 
      strings or template strings -->
    <script id="2d-vertex-shader" type="shader">
      // this attribute will receive position data from a buffer
			attribute vec2 a_position; // pixels, instead of clipspace
			uniform vec2 u_resolution;

      void main() {
				// convert position from pixels to 0.0 to 1.0
				vec2 zeroToOne = a_position / u_resolution;
					
				vec2 zeroToTwo = zeroToOne * 2.0;

				vec2 clipSpace = zeroToTwo - 1.0;	
        // gl_Position is a magic global that the vertext shader
        // must set
				// flip the canvas so that 0,0 is in the top left corner. webgl defaults to the bottom left,
				// which is weird
        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
      }
    </script>

    <script id="2d-fragment-shader" type="shader">
      precision mediump float;

      void main() {
        // gl_FragColor is a magic global the fragment shader must set
        gl_FragColor = vec4(1, 0, 0.5, 1); // colors in webgl go from 0 to 1
      }
    </script>
    <script>
      const canvas = document.getElementById('canvas');
      const gl = canvas.getContext('webgl');
      const vertexShaderSource = document.getElementById('2d-vertex-shader').text;
      const fragmentShaderSource = document.getElementById('2d-fragment-shader').text;

			const resizeCanvasToDisplaySize = (canvas) => {
				// Lookup the size the browser is displaying the canvas.
				var displayWidth  = canvas.clientWidth;
				var displayHeight = canvas.clientHeight;
			 
				// Check if the canvas is not the same size.
				if (canvas.width  != displayWidth ||
						canvas.height != displayHeight) {
			 
					// Make the canvas the same size
					canvas.width  = displayWidth;
					canvas.height = displayHeight;
				}
			}

      const createShader = (gl, type, source) => {
        const shader = gl.createShader(type);

        gl.shaderSource(shader, source);
        gl.compileShader(shader);

        const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

        if (success) return shader;

        console.log('Error creating shader: ', gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
      };

      const createProgram = (gl, vertexShader, fragmentShader) => {
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        const success = gl.getProgramParameter(program, gl.LINK_STATUS);

        if (success) return program;

        console.log(gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
      };

      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource); 
      const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource); 
      const program = createProgram(gl, vertexShader, fragmentShader);
      
      // first we look up the location of the position attribute. lookups should not
      // be done in a render loop!
      const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');
			const resolutionUniformLocation = gl.getUniformLocation(program, "u_resolution");
      const positionBuffer = gl.createBuffer();
      
      // WebGL exposes many resources on global bind points. These are global variables
      // within webGL. We can bind resources to bind points, and other function can refer
      // to that resource via the bind point.
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

      const positions = [ 20, 20, 20, 80, 200, 20 ];
      // webgl only accepts types arrays so we have to convert out position data into a
      // float32 array. STATIC_DRAW is a hint to webgl that the position data is
      // unlikely to change
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
			
			// make sure the canvas size and drawing size match pixels
			resizeCanvasToDisplaySize(gl.canvas);
			// tell webgl what size our canvas is
			gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
			gl.clearColor(0, 0, 0, 0);
			gl.clear(gl.COLOR_BUFFER_BIT);
			
			gl.useProgram(program);
			

			gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
			// turn on the attribute we bound earlier
			gl.enableVertexAttribArray(positionAttributeLocation);
			
			// instructions for how the attribute will get data out of the positionBuffer
			const size = 2; // 2 elements per iteration
			const type = gl.FLOAT; // data being read is a 32bit float
			const normalize = false; // don't normalize data (whatever that means)
			const stride = 0; // 0 means the next position is derived from size * sizeof(type)
			const offset = 0; // position at which to start reading data
			// this also binds the current ARRAY_BUFFER (positionBuffer in this case) to the attribute
			// supplied to this function (positionAttributeLocation). That means that ARRAY_BUFFER
			// can now be rebound
			gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

			const primitiveType = gl.TRIANGLES;
			const drawOffset = 0;
			const count = 3;
			gl.drawArrays(primitiveType, drawOffset, count);
		

			// webgl renders in clipspace by default. In clipspace, 0 x and y represents the center of the canvas
			// -1 is the bottom or left, and 1 is the top or right.
    </script>
  </body>
</html>
